// --- HYPER GENERATED CODE %VERSION% 1637347800 ---
//
// WARNING
//
// This file was automatically generated by the Hyper Platform.
// Manual changes MUST NOT be made, consult documentation at hyper.ag for more
// information.

#ifndef __HYPER_DEVICE_CLASS_12__
#define __HYPER_DEVICE_CLASS_12__

#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include "cmp.h"
#include "hyper_device_core_v3.h"

// --- DEVICE TYPE ---
typedef struct {
  uint8_t version;
  uint32_t device_class_id;
  uint8_t device_id[6];
  

  uint8_t environment_temperature_set : 1;
  float environment_temperature;
  uint8_t humidity_set : 1;
  float humidity;
  uint8_t illuminance_set : 1;
  float illuminance;
  uint8_t firmware_version_size;
  uint8_t firmware_version[16];
  uint8_t reboot_set : 1;
  bool reboot;
  uint8_t uptime_set : 1;
  uint64_t uptime;
  uint8_t publish_interval_set : 1;
  uint16_t publish_interval;
  
  void (*on_reboot_update)(bool);
  void (*on_publish_interval_update)(uint16_t);
} hyper_device_12_t;

void hyper_device_12_reset(hyper_device_12_t * device) {
  device->environment_temperature_set = 0;
  device->environment_temperature = 0.0;
  device->humidity_set = 0;
  device->humidity = 0.0;
  device->illuminance_set = 0;
  device->illuminance = 0.0;
  device->firmware_version_size = 0;
  memset(device->firmware_version, 0, sizeof(device->firmware_version));
  device->reboot_set = 0;
  device->reboot = false;
  device->uptime_set = 0;
  device->uptime = 0;
  device->publish_interval_set = 0;
  device->publish_interval = 0;
}


void hyper_device_12_init(hyper_device_12_t * device, uint8_t device_id[6]) {
  device->version = 3;
  device->device_class_id = 12;
  memcpy(device->device_id, device_id, 6);
  hyper_device_12_reset(device);
  device->on_reboot_update = NULL;
  device->on_publish_interval_update = NULL;
}


// --- PRINT DEVICE ---
void hyper_device_12_print(hyper_device_12_t * device) {
  HYPER_PRINTF(
    "(hyper_device_12_t\n"
    "  (version %d)\n"
    "  (device_class_id %lu)\n"
    "  (device_id (%02x %02x %02x %02x %02x %02x))\n",
    device->version, (long unsigned)device->device_class_id, device->device_id[0],
    device->device_id[1], device->device_id[2], device->device_id[3],
    device->device_id[4], device->device_id[5]);
      

  if (device->environment_temperature_set) {
    HYPER_PRINTF("  (environment_temperature (f32 %f))\n", device->environment_temperature);
  } else {
    HYPER_PRINTF("  (environment_temperature (f32 none))\n");
  }

  if (device->humidity_set) {
    HYPER_PRINTF("  (humidity (f32 %f))\n", device->humidity);
  } else {
    HYPER_PRINTF("  (humidity (f32 none))\n");
  }

  if (device->illuminance_set) {
    HYPER_PRINTF("  (illuminance (f32 %f))\n", device->illuminance);
  } else {
    HYPER_PRINTF("  (illuminance (f32 none))\n");
  }

  if (device->firmware_version_size > 0) {
    HYPER_PRINTF("  (firmware_version ((data<16> %u)", device->firmware_version_size);
    for (uint8_t i = 0; i < device->firmware_version_size; i += 1) {
      HYPER_PRINTF(" %02x", device->firmware_version[i]);
    };
    HYPER_PRINTF("))\n");
  } else {
    HYPER_PRINTF("  (firmware_version (data<0> none))\n");
  }
      

  if (device->reboot_set) {
    HYPER_PRINTF("  (reboot (bool %d))\n", device->reboot);
  } else {
    HYPER_PRINTF("  (reboot (bool none))\n");
  }

  if (device->uptime_set) {
    HYPER_PRINTF("  (uptime (u64 %llu))\n", device->uptime);
  } else {
    HYPER_PRINTF("  (uptime (u64 none))\n");
  }

  if (device->publish_interval_set) {
    HYPER_PRINTF("  (publish_interval (u16 %u))\n", device->publish_interval);
  } else {
    HYPER_PRINTF("  (publish_interval (u16 none))\n");
  }
  HYPER_PRINTF(")\n");
}


// --- BIND ATTRIBUTES ---
void hyper_device_12_bind_reboot(hyper_device_12_t * device, void (*callback)(bool)) {
  device->on_reboot_update = callback;
}


void hyper_device_12_bind_publish_interval(hyper_device_12_t * device, void (*callback)(uint16_t)) {
  device->on_publish_interval_update = callback;
}


// --- SET ATTRIBUTES ---
void hyper_device_12_set_environment_temperature(hyper_device_12_t * device, float value) {
  device->environment_temperature_set = 1;
  device->environment_temperature = value;
}


void hyper_device_12_set_humidity(hyper_device_12_t * device, float value) {
  device->humidity_set = 1;
  device->humidity = value;
}


void hyper_device_12_set_illuminance(hyper_device_12_t * device, float value) {
  device->illuminance_set = 1;
  device->illuminance = value;
}


hyper_result_t hyper_device_12_set_firmware_version(hyper_device_12_t * device, uint8_t * value, uint8_t value_size) {
  if (value_size > sizeof(device->firmware_version)) {
    HYPER_PRINTF("data value too large");
    return HYPER_ERR_ATTRIBUTE_SET;
  }

  device->firmware_version_size = value_size;
  memcpy(device->firmware_version, value, value_size);

  return HYPER_OK;
      
}


void hyper_device_12_set_reboot(hyper_device_12_t * device, bool value) {
  device->reboot_set = 1;
  device->reboot = value;
}


void hyper_device_12_set_uptime(hyper_device_12_t * device, uint64_t value) {
  device->uptime_set = 1;
  device->uptime = value;
}


void hyper_device_12_set_publish_interval(hyper_device_12_t * device, uint16_t value) {
  device->publish_interval_set = 1;
  device->publish_interval = value;
}


// --- ENCODE DEVICE ---
hyper_result_t hyper_device_12_encode(hyper_device_12_t * device, uint8_t * out, uint8_t * out_len) {
  cmp_ctx_t cmp_ctx = {0};
  buffer_t msgpack_buf = {out, 0};

  cmp_init(&cmp_ctx, (void *)&msgpack_buf, NULL, NULL, hyper_device_msgpack_writer);

  // Encode message as array of elements.
  if (!cmp_write_array(&cmp_ctx, 3)) {
    HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
    return HYPER_ERR_ENCODE;
  }
         
  // Device info.
  if (!cmp_write_u32(&cmp_ctx, device->device_class_id)) {
    HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
    return HYPER_ERR_ENCODE;
  }

  if (!cmp_write_bin(&cmp_ctx, device->device_id, 6)) {
    HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
    return HYPER_ERR_ENCODE;
  }

  uint8_t defined_attributes_count = 0;
  if (device->environment_temperature_set) ++defined_attributes_count;
  if (device->humidity_set) ++defined_attributes_count;
  if (device->illuminance_set) ++defined_attributes_count;
  if (device->firmware_version_size > 0) ++defined_attributes_count;
  if (device->reboot_set) ++defined_attributes_count;
  if (device->uptime_set) ++defined_attributes_count;
  if (device->publish_interval_set) ++defined_attributes_count;

  // Attributes
  if (!cmp_write_map(&cmp_ctx, defined_attributes_count)) {
    HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
    return HYPER_ERR_ENCODE;
  }

  // 0: environment_temperature
  if (device->environment_temperature_set) {
    if (!cmp_write_u8(&cmp_ctx, 0)) {
      HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return HYPER_ERR_ENCODE;
    }
    if (!cmp_write_float(&cmp_ctx, device->environment_temperature)) {
      HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return HYPER_ERR_ENCODE;
    }
  }

  // 1: humidity
  if (device->humidity_set) {
    if (!cmp_write_u8(&cmp_ctx, 1)) {
      HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return HYPER_ERR_ENCODE;
    }
    if (!cmp_write_float(&cmp_ctx, device->humidity)) {
      HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return HYPER_ERR_ENCODE;
    }
  }

  // 2: illuminance
  if (device->illuminance_set) {
    if (!cmp_write_u8(&cmp_ctx, 2)) {
      HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return HYPER_ERR_ENCODE;
    }
    if (!cmp_write_float(&cmp_ctx, device->illuminance)) {
      HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return HYPER_ERR_ENCODE;
    }
  }

  // 3: firmware_version
  if (device->firmware_version_size > 0) {
    if (!cmp_write_u8(&cmp_ctx, 3)) {
      HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return HYPER_ERR_ENCODE;
    }
    if (!cmp_write_bin(&cmp_ctx, device->firmware_version, device->firmware_version_size)) {
      HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return HYPER_ERR_ENCODE;
    }
  }

  // 4: reboot
  if (device->reboot_set) {
    if (!cmp_write_u8(&cmp_ctx, 4)) {
      HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return HYPER_ERR_ENCODE;
    }
    if (!cmp_write_bool(&cmp_ctx, device->reboot)) {
      HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return HYPER_ERR_ENCODE;
    }
  }

  // 5: uptime
  if (device->uptime_set) {
    if (!cmp_write_u8(&cmp_ctx, 5)) {
      HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return HYPER_ERR_ENCODE;
    }
    if (!cmp_write_u64(&cmp_ctx, device->uptime)) {
      HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return HYPER_ERR_ENCODE;
    }
  }

  // 6: publish_interval
  if (device->publish_interval_set) {
    if (!cmp_write_u8(&cmp_ctx, 6)) {
      HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return HYPER_ERR_ENCODE;
    }
    if (!cmp_write_u16(&cmp_ctx, device->publish_interval)) {
      HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return HYPER_ERR_ENCODE;
    }
  }

  *out_len = msgpack_buf.offset;
  return HYPER_OK;
}


// --- DECODE DEVICE ---
hyper_result_t hyper_device_12_decode(hyper_device_12_t * device, uint8_t * in, uint8_t in_size) {
  cmp_ctx_t cmp_ctx = {0};
  buffer_t msgpack_buf = {in, 0};

  cmp_init(&cmp_ctx, (void *)&msgpack_buf, hyper_device_msgpack_reader, NULL, NULL);
      
  uint32_t msg_array_size = 0;

  // Main msg array
  if (!cmp_read_array(&cmp_ctx, &msg_array_size) && msg_array_size != 3) {
    HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
    return HYPER_ERR_DECODE;
  }

  cmp_object_t obj;

  // Device class id
  if (!cmp_read_object(&cmp_ctx, &obj)) {
    HYPER_PRINTF("%s\n", "could not read object");
    return HYPER_ERR_DECODE;
  }
  if (!cmp_object_as_uint(&obj, &device->device_class_id)) {
    HYPER_PRINTF("%s\n", "could not read device_class_id\n");
    return HYPER_ERR_DECODE;
  }

  // Device id
  uint32_t device_id_size = 0;
  if (!cmp_read_bin_size(&cmp_ctx, &device_id_size)) {
    HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
    return HYPER_ERR_DECODE;
  }

  if (device_id_size != 6) {
    HYPER_PRINTF("%s\n", "hyper_device_decode: wrong device_id_size\n");
    return HYPER_ERR_DECODE;
  }

  memcpy(device->device_id, in + msgpack_buf.offset, 6);
  msgpack_buf.offset += 6;

  // Attributes
  uint32_t attributes_map_len = 0;
  if (!cmp_read_map(&cmp_ctx, &attributes_map_len)) {
    HYPER_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
    return HYPER_ERR_DECODE;
  }

  uint8_t key = 0xFF;
  for (uint16_t i = 0; i < attributes_map_len; ++i) {
    // Key
    if (!cmp_read_object(&cmp_ctx, &obj)) {
      HYPER_PRINTF("%s\n", "could not read map key");
      return HYPER_ERR_DECODE;
    }
    if (cmp_object_as_uchar(&obj, &key)) {
      // Value
      if (!cmp_read_object(&cmp_ctx, &obj)) {
        HYPER_PRINTF("%s\n", "could not read attribute value");
        return HYPER_ERR_DECODE;
      }
      switch (key) {
      case 0: // environment_temperature
        if (cmp_object_as_float(&obj, &device->environment_temperature)) {
          device->environment_temperature_set = 1; 
        } else {
          HYPER_PRINTF("%s\n", "could not read value\n");
            return HYPER_ERR_DECODE;
        }
        break;

      case 1: // humidity
        if (cmp_object_as_float(&obj, &device->humidity)) {
          device->humidity_set = 1; 
        } else {
          HYPER_PRINTF("%s\n", "could not read value\n");
            return HYPER_ERR_DECODE;
        }
        break;

      case 2: // illuminance
        if (cmp_object_as_float(&obj, &device->illuminance)) {
          device->illuminance_set = 1; 
        } else {
          HYPER_PRINTF("%s\n", "could not read value\n");
            return HYPER_ERR_DECODE;
        }
        break;

      case 3: // firmware_version
        if (cmp_object_as_bin(&obj, (uint32_t *)&device->firmware_version_size)) {
          memcpy(device->firmware_version, in + msgpack_buf.offset, device->firmware_version_size);
          msgpack_buf.offset += device->firmware_version_size;
        } else {
          HYPER_PRINTF("%s\n", "could not read value\n");
            return HYPER_ERR_DECODE;
        }
        break;

      case 4: // reboot
        if (cmp_object_as_bool(&obj, &device->reboot)) {
          device->reboot_set = 1; 
        } else {
          HYPER_PRINTF("%s\n", "could not read value\n");
            return HYPER_ERR_DECODE;
        }
        break;

      case 5: // uptime
        if (cmp_object_as_ulong(&obj, &device->uptime)) {
          device->uptime_set = 1; 
        } else {
          HYPER_PRINTF("%s\n", "could not read value\n");
            return HYPER_ERR_DECODE;
        }
        break;

      case 6: // publish_interval
        if (cmp_object_as_ushort(&obj, &device->publish_interval)) {
          device->publish_interval_set = 1; 
        } else {
          HYPER_PRINTF("%s\n", "could not read value\n");
            return HYPER_ERR_DECODE;
        }
        break;

      default:
        HYPER_PRINTF("%s\n", "attribute index out of bounds\n");
        return HYPER_ERR_DECODE;
      }
    } else {
      HYPER_PRINTF("%s\n", "could not read value\n");
      return HYPER_ERR_DECODE;
    }
  }
  return HYPER_OK;
}


// --- DISPATCH DEVICE ---
void hyper_device_12_dispatch(hyper_device_12_t * device) {
  if (device->on_reboot_update && device->reboot_set) {
    device->on_reboot_update(device->reboot);
  }
  if (device->on_publish_interval_update && device->publish_interval_set) {
    device->on_publish_interval_update(device->publish_interval);
  }
}


#endif // __HYPER_DEVICE_CLASS_12__
